<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wirlwind Telemetry</title>
<script src="qrc:///qtwebchannel/qwebchannel.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700;900&family=JetBrains+Mono:wght@300;400;500;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
:root {
  --bg-primary: #0a0e14;
  --bg-panel: #111820;
  --bg-panel-header: #151d27;
  --border: #1e2a38;
  --border-accent: #2a3a4e;
  --text-primary: #c8d6e5;
  --text-secondary: #6b7d93;
  --text-dim: #3d4f63;
  --green: #00e676;
  --green-dim: #00e67633;
  --amber: #ffab00;
  --amber-dim: #ffab0033;
  --red: #ff1744;
  --red-dim: #ff174433;
  --cyan: #00e5ff;
  --cyan-dim: #00e5ff22;
  --blue: #2979ff;
  --blue-dim: #2979ff33;
  --purple: #d500f9;
  --scanline: rgba(0,229,255,0.03);
}
* { margin:0; padding:0; box-sizing:border-box; }
body {
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 12px;
  overflow-x: hidden;
}
body::after {
  content:''; position:fixed; top:0;left:0;right:0;bottom:0;
  background: repeating-linear-gradient(0deg, transparent, transparent 2px, var(--scanline) 2px, var(--scanline) 4px);
  pointer-events:none; z-index:9999;
}

/* Header */
.header {
  background: linear-gradient(180deg, #0f1822 0%, var(--bg-primary) 100%);
  border-bottom: 1px solid var(--border);
  padding: 10px 16px;
  display: flex; align-items: center; justify-content: space-between;
  position: relative;
}
.header::after {
  content:''; position:absolute; bottom:0;left:0;right:0; height:1px;
  background: linear-gradient(90deg, transparent, var(--cyan), transparent); opacity:0.4;
}
.header-left { display:flex; align-items:center; gap:16px; }
.logo-mark {
  width:32px; height:32px; border:2px solid var(--cyan); border-radius:3px;
  display:flex; align-items:center; justify-content:center;
  font-family:'Orbitron',monospace; font-weight:900; font-size:12px;
  color:var(--cyan); background:var(--cyan-dim);
  text-shadow:0 0 10px var(--cyan); box-shadow:0 0 12px var(--cyan-dim);
}
.device-identity h1 {
  font-family:'Orbitron',monospace; font-size:14px; font-weight:700;
  color:var(--text-primary); letter-spacing:2px; text-transform:uppercase;
}
.device-identity .subtitle { font-size:10px; color:var(--text-secondary); letter-spacing:1px; margin-top:1px; }
.header-meta { display:flex; gap:20px; align-items:center; }
.meta-item { text-align:right; }
.meta-label { font-size:9px; color:var(--text-dim); text-transform:uppercase; letter-spacing:1.5px; }
.meta-value { font-size:11px; color:var(--text-secondary); font-weight:500; }
.meta-value.status-up { color:var(--green); text-shadow:0 0 8px var(--green-dim); }
.status-dot {
  display:inline-block; width:6px; height:6px; background:var(--green);
  border-radius:50%; margin-right:4px; box-shadow:0 0 6px var(--green);
  animation: pulse-dot 2s ease-in-out infinite;
}
@keyframes pulse-dot { 0%,100%{opacity:1;} 50%{opacity:0.4;} }
.live-clock { font-family:'Share Tech Mono',monospace; font-size:11px; color:var(--cyan); text-shadow:0 0 8px var(--cyan-dim); }

/* Info strip */
.info-strip {
  background:var(--bg-panel); border-bottom:1px solid var(--border);
  padding:6px 16px; display:flex; gap:28px; font-size:11px; overflow-x:auto;
}
.info-chip { display:flex; align-items:center; gap:5px; white-space:nowrap; }
.info-chip .label { color:var(--text-dim); text-transform:uppercase; font-size:9px; letter-spacing:1px; }
.info-chip .value { color:var(--text-secondary); font-weight:500; }

/* Grid */
.dashboard { display:grid; grid-template-columns:1fr 1fr 1fr; gap:2px; padding:2px; background:var(--bg-primary); }
.panel { background:var(--bg-panel); border:1px solid var(--border); overflow:hidden; position:relative; }
.panel-header {
  background:var(--bg-panel-header); padding:7px 12px;
  display:flex; align-items:center; justify-content:space-between;
  border-bottom:1px solid var(--border); position:relative;
}
.panel-header::before { content:''; position:absolute; left:0;top:0;bottom:0; width:3px; }
.panel-header.green::before { background:var(--green); box-shadow:0 0 8px var(--green-dim); }
.panel-header.amber::before { background:var(--amber); box-shadow:0 0 8px var(--amber-dim); }
.panel-header.cyan::before { background:var(--cyan); box-shadow:0 0 8px var(--cyan-dim); }
.panel-header.blue::before { background:var(--blue); box-shadow:0 0 8px var(--blue-dim); }
.panel-header.red::before { background:var(--red); box-shadow:0 0 8px var(--red-dim); }
.panel-header.purple::before { background:var(--purple); }
.panel-title {
  font-family:'Orbitron',monospace; font-size:9px; font-weight:600;
  letter-spacing:2px; text-transform:uppercase; color:var(--text-secondary);
}
.panel-header-right { display:flex; align-items:center; gap:6px; }
.panel-badge {
  font-size:9px; padding:2px 7px; border-radius:2px; font-weight:600; letter-spacing:1px;
}
.badge-ok { background:var(--green-dim); color:var(--green); border:1px solid #00e67644; }
.badge-warn { background:var(--amber-dim); color:var(--amber); border:1px solid #ffab0044; }
.badge-crit { background:var(--red-dim); color:var(--red); border:1px solid #ff174444; }
.badge-none { background:#1e2a3844; color:var(--text-dim); border:1px solid var(--border); }
.badge-error { background:var(--red-dim); color:var(--red); border:1px solid #ff174444; font-size:8px; }
.panel-body { padding:10px; min-height:200px; display:flex; align-items:center; justify-content:center; }
.chart-container { width:100%; height:100%; min-height:200px; }
.span-2 { grid-column:span 2; }
.span-3 { grid-column:span 3; }
.tall { min-height:310px; }
.tall .panel-body { min-height:280px; }

/* JSON Debug button */
.debug-btn {
  background: transparent;
  border: 1px solid var(--border);
  color: var(--text-dim);
  font-family: 'JetBrains Mono', monospace;
  font-size: 10px;
  font-weight: 700;
  padding: 1px 5px;
  border-radius: 2px;
  cursor: pointer;
  line-height: 1.3;
  transition: all 0.15s ease;
  opacity: 0.5;
}
.intf-select {
  background: var(--bg-primary);
  color: var(--text-secondary);
  border: 1px solid var(--border-accent);
  font-family: 'Share Tech Mono', monospace;
  font-size: 10px;
  padding: 2px 4px;
  border-radius: 3px;
  cursor: pointer;
  max-width: 180px;
  outline: none;
}
.intf-select:hover { border-color: var(--cyan); color: var(--text-primary); }
.intf-select:focus { border-color: var(--cyan); color: var(--text-primary); }
.intf-select option { background: var(--bg-panel); color: var(--text-primary); }

.debug-btn:hover {
  border-color: var(--cyan);
  color: var(--cyan);
  background: var(--cyan-dim);
  opacity: 1;
  text-shadow: 0 0 6px var(--cyan-dim);
}
.debug-btn.has-data {
  opacity: 0.7;
}
.debug-btn.has-error {
  border-color: var(--red);
  color: var(--red);
  opacity: 0.9;
}

/* JSON Debug Modal */
.debug-modal-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.85);
  z-index: 10000;
  justify-content: center;
  align-items: center;
  padding: 24px;
}
.debug-modal-overlay.visible {
  display: flex;
}
.debug-modal {
  background: #0d1218;
  border: 1px solid var(--border-accent);
  border-radius: 4px;
  max-width: 900px;
  width: 100%;
  max-height: 85vh;
  display: flex;
  flex-direction: column;
  box-shadow: 0 8px 40px rgba(0,0,0,0.6), 0 0 1px var(--cyan);
}
.debug-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 16px;
  border-bottom: 1px solid var(--border);
  background: var(--bg-panel-header);
}
.debug-modal-title {
  font-family: 'Orbitron', monospace;
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--cyan);
}
.debug-modal-meta {
  display: flex;
  align-items: center;
  gap: 12px;
}
.debug-parser-tag {
  font-size: 9px;
  padding: 2px 6px;
  border-radius: 2px;
  font-weight: 600;
  letter-spacing: 0.5px;
  font-family: 'Share Tech Mono', monospace;
}
.parser-textfsm { background: #00e67622; color: var(--green); border: 1px solid #00e67644; }
.parser-ttp { background: #2979ff22; color: var(--blue); border: 1px solid #2979ff44; }
.parser-regex { background: #ffab0022; color: var(--amber); border: 1px solid #ffab0044; }
.parser-none { background: var(--red-dim); color: var(--red); border: 1px solid #ff174444; }
.debug-modal-actions { display:flex; gap:6px; }
.debug-action-btn {
  background: var(--bg-panel);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  font-family: 'JetBrains Mono', monospace;
  font-size: 10px;
  padding: 3px 10px;
  border-radius: 2px;
  cursor: pointer;
  transition: all 0.15s ease;
}
.debug-action-btn:hover {
  border-color: var(--cyan);
  color: var(--cyan);
  background: var(--cyan-dim);
}
.debug-action-btn.copied {
  border-color: var(--green);
  color: var(--green);
}
.debug-modal-body {
  flex: 1;
  overflow-y: auto;
  padding: 12px 16px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  line-height: 1.6;
  white-space: pre-wrap;
  word-break: break-word;
  color: var(--text-secondary);
}
.debug-modal-body::-webkit-scrollbar { width:6px; }
.debug-modal-body::-webkit-scrollbar-track { background:#0d1218; }
.debug-modal-body::-webkit-scrollbar-thumb { background:var(--border-accent); border-radius:3px; }

/* JSON syntax highlighting */
.json-key { color: var(--cyan); }
.json-string { color: var(--green); }
.json-number { color: var(--amber); }
.json-bool { color: var(--purple); }
.json-null { color: var(--text-dim); }
.json-meta-key { color: var(--red); }

/* Tables */
.data-table { width:100%; border-collapse:collapse; font-size:11px; }
.data-table th {
  text-align:left; padding:5px 8px; color:var(--text-dim); font-size:9px;
  text-transform:uppercase; letter-spacing:1.5px; font-weight:600;
  border-bottom:1px solid var(--border); background:var(--bg-panel-header);
  position:sticky; top:0; z-index:1;
}
.data-table td { padding:4px 8px; border-bottom:1px solid #111820; color:var(--text-secondary); font-family:'Share Tech Mono',monospace; }
.data-table tr:hover td { background:#0d1520; }
.intf-up { color:var(--green); }
.intf-down { color:var(--red); }
.intf-admin { color:var(--text-dim); }
.util-bar { height:4px; background:var(--border); border-radius:2px; overflow:hidden; min-width:50px; display:inline-block; vertical-align:middle; margin-right:4px; }
.util-bar-fill { height:100%; border-radius:2px; }
.util-low { background:var(--green); box-shadow:0 0 4px var(--green-dim); }
.util-med { background:var(--amber); box-shadow:0 0 4px var(--amber-dim); }
.util-high { background:var(--red); box-shadow:0 0 4px var(--red-dim); }
.table-scroll { overflow-y:auto; width:100%; }
.table-scroll::-webkit-scrollbar { width:4px; }
.table-scroll::-webkit-scrollbar-track { background:var(--bg-panel); }
.table-scroll::-webkit-scrollbar-thumb { background:var(--border-accent); border-radius:2px; }

/* Log entries */
.log-entry { padding:2px 8px; font-family:'Share Tech Mono',monospace; font-size:11px; border-bottom:1px solid #111820; }
.log-entry:hover { background:#0d1520; }
.log-ts { color:var(--text-dim); margin-right:8px; }
.log-sev-0,.log-sev-1,.log-sev-2 { color:var(--red); }
.log-sev-3 { color:var(--red); }
.log-sev-4 { color:var(--amber); }
.log-sev-5 { color:var(--cyan); }
.log-sev-6,.log-sev-7 { color:var(--text-dim); }
.log-msg { color:var(--text-secondary); }

/* Waiting state */
.waiting {
  color:var(--text-dim); font-family:'Share Tech Mono',monospace;
  font-size:11px; text-align:center;
}
.waiting .spinner {
  display:inline-block; width:16px; height:16px; border:2px solid var(--border-accent);
  border-top-color:var(--cyan); border-radius:50%; animation:spin 1s linear infinite;
  margin-bottom:6px;
}
@keyframes spin { to{transform:rotate(360deg);} }

/* No-data state (replaces spinner after timeout) */
.no-data {
  color:var(--text-dim); font-family:'Share Tech Mono',monospace;
  font-size:11px; text-align:center;
}

@media (max-width:1200px) { .dashboard{grid-template-columns:1fr 1fr;} .span-3{grid-column:span 2;} }
@media (max-width:768px) { .dashboard{grid-template-columns:1fr;} .span-2,.span-3{grid-column:span 1;} }
</style>
</head>
<body>

<div class="header">
  <div class="header-left">
    <div class="logo-mark">WT</div>
    <div class="device-identity">
      <h1 id="deviceHostname">Waiting for connection...</h1>
      <div class="subtitle" id="deviceSubtitle">—</div>
    </div>
  </div>
  <div class="header-meta">
    <div class="meta-item">
      <div class="meta-label">Status</div>
      <div class="meta-value" id="connStatus"><span class="status-dot" id="statusDot" style="background:var(--amber)"></span>CONNECTING</div>
    </div>
    <div class="meta-item">
      <div class="meta-label">Last Poll</div>
      <div class="meta-value live-clock" id="liveClock">--:--:--</div>
    </div>
    <div class="meta-item">
      <div class="meta-label">Vendor</div>
      <div class="meta-value" id="vendorLabel">—</div>
    </div>
  </div>
</div>

<div class="info-strip" id="infoStrip">
  <div class="info-chip"><span class="label">Awaiting data...</span></div>
</div>

<div class="dashboard">
  <!-- CPU Gauge -->
  <div class="panel" data-collection="cpu">
    <div class="panel-header green">
      <span class="panel-title">CPU Utilization</span>
      <div class="panel-header-right">
        <button class="debug-btn" onclick="showDebug('cpu')" title="Inspect parsed data">{ }</button>
        <span class="panel-badge badge-none" id="cpuBadge">—</span>
      </div>
    </div>
    <div class="panel-body"><div class="chart-container" id="cpuGauge"></div></div>
  </div>

  <!-- Memory Gauge -->
  <div class="panel" data-collection="memory">
    <div class="panel-header amber">
      <span class="panel-title">Memory Utilization</span>
      <div class="panel-header-right">
        <button class="debug-btn" onclick="showDebug('memory')" title="Inspect parsed data">{ }</button>
        <span class="panel-badge badge-none" id="memBadge">—</span>
      </div>
    </div>
    <div class="panel-body"><div class="chart-container" id="memGauge"></div></div>
  </div>

  <!-- Top Processes -->
  <div class="panel" data-collection="processes">
    <div class="panel-header green">
      <span class="panel-title">Top Processes</span>
      <div class="panel-header-right">
        <button class="debug-btn" onclick="showDebug('cpu')" title="Inspect parsed data (from CPU collection)">{ }</button>
      </div>
    </div>
    <div class="panel-body" style="align-items:flex-start;padding:0;">
      <div class="table-scroll" style="max-height:200px;" id="processContainer">
        <div class="waiting"><div class="spinner"></div><br>Waiting for data</div>
      </div>
    </div>
  </div>

  <!-- Throughput -->
  <div class="panel span-2 tall" data-collection="interface_detail">
    <div class="panel-header blue">
      <span class="panel-title">Interface Throughput</span>
      <div class="panel-header-right">
        <select id="intfSelect" class="intf-select" onchange="renderThroughputChart()" title="Filter by interface">
          <option value="__aggregate__">All Interfaces</option>
        </select>
        <button class="debug-btn" onclick="showDebug('interface_detail')" title="Inspect parsed data">{ }</button>
        <span class="panel-badge badge-none" id="thruBadge">—</span>
      </div>
    </div>
    <div class="panel-body"><div class="chart-container" id="throughputChart"></div></div>
  </div>

  <!-- Neighbors -->
  <div class="panel tall" data-collection="neighbors">
    <div class="panel-header cyan">
      <span class="panel-title">LLDP / CDP Neighbors</span>
      <div class="panel-header-right">
        <button class="debug-btn" onclick="showDebug('neighbors')" title="Inspect parsed data">{ }</button>
      </div>
    </div>
    <div class="panel-body"><div class="chart-container" id="neighborGraph"></div></div>
  </div>

  <!-- CPU/Memory Trend -->
  <div class="panel span-2 tall" data-collection="history">
    <div class="panel-header purple">
      <span class="panel-title">CPU &amp; Memory Trend</span>
      <div class="panel-header-right">
        <button class="debug-btn" onclick="showDebug('_history')" title="Inspect history buffer">{ }</button>
      </div>
    </div>
    <div class="panel-body"><div class="chart-container" id="historyChart"></div></div>
  </div>

  <!-- Log View -->
  <div class="panel tall" data-collection="log">
    <div class="panel-header red">
      <span class="panel-title">Device Log</span>
      <div class="panel-header-right">
        <button class="debug-btn" onclick="showDebug('log')" title="Inspect parsed data">{ }</button>
        <span class="panel-badge badge-none" id="logBadge">—</span>
      </div>
    </div>
    <div class="panel-body" style="align-items:flex-start;padding:0;">
      <div class="table-scroll" style="max-height:280px;" id="logContainer">
        <div class="waiting"><div class="spinner"></div><br>Waiting for data</div>
      </div>
    </div>
  </div>

  <!-- Interface Table -->
  <div class="panel span-3" data-collection="interfaces">
    <div class="panel-header blue">
      <span class="panel-title">Interface Status</span>
      <div class="panel-header-right">
        <button class="debug-btn" onclick="showDebug('interfaces')" title="Inspect parsed data">{ }</button>
        <span class="panel-badge badge-none" id="intfBadge">—</span>
      </div>
    </div>
    <div class="panel-body" style="align-items:flex-start;padding:0;">
      <div class="table-scroll" style="max-height:260px;width:100%;" id="intfContainer">
        <div class="waiting"><div class="spinner"></div><br>Waiting for data</div>
      </div>
    </div>
  </div>
</div>

<!-- ═══════════════════════════════════════════════════════════════════
     JSON DEBUG MODAL
     ═══════════════════════════════════════════════════════════════════ -->
<div class="debug-modal-overlay" id="debugOverlay">
  <div class="debug-modal">
    <div class="debug-modal-header">
      <span class="debug-modal-title" id="debugTitle">—</span>
      <div class="debug-modal-meta">
        <span class="debug-parser-tag" id="debugParserTag" style="display:none"></span>
        <span class="debug-parser-tag" id="debugTemplateTag" style="display:none"></span>
        <div class="debug-modal-actions">
          <button class="debug-action-btn" id="debugCopyBtn" onclick="copyDebugJSON()">Copy</button>
          <button class="debug-action-btn" onclick="closeDebug()">Close</button>
        </div>
      </div>
    </div>
    <div class="debug-modal-body" id="debugBody">No data</div>
  </div>
</div>

<script>
// ══════════════════════════════════════════════════════════════════════
// WIRLWIND TELEMETRY DASHBOARD
// Live data via QWebChannel ↔ Python bridge
// ══════════════════════════════════════════════════════════════════════

let bridge = null;
const charts = {};
const throughputHistory = {
  timestamps: [],
  perInterface: {}   // { "Ethernet1/0": { inbound: [], outbound: [] }, ... }
};
const THROUGHPUT_MAX = 72; // 6 hours at 5-min intervals
const knownInterfaces = new Set();

// Helper: QWebChannel slots return Promises in PyQt6.
// This handles both sync (Qt5-style) and async (Qt6-style) returns.
function bridgeCall(method) {
  var args = Array.prototype.slice.call(arguments, 1);
  try {
    var result = method.apply(bridge, args);
    if (result && typeof result.then === 'function') {
      return result; // Already a Promise
    }
    return Promise.resolve(result); // Wrap sync value
  } catch(e) {
    return Promise.reject(e);
  }
}

// Store last-known data per collection for debug inspection
const collectionCache = {};
// Track poll cycles for spinner timeout
const panelPollCount = {};
const SPINNER_TIMEOUT_CYCLES = 3;
let totalCycles = 0;

// ── Chart initialization ───────────────────────────────────────────

function initCharts() {
  charts.cpu = echarts.init(document.getElementById('cpuGauge'));
  charts.mem = echarts.init(document.getElementById('memGauge'));
  charts.throughput = echarts.init(document.getElementById('throughputChart'));
  charts.neighbor = echarts.init(document.getElementById('neighborGraph'));
  charts.history = echarts.init(document.getElementById('historyChart'));

  // CPU Gauge
  charts.cpu.setOption(gaugeOption(0, '—'));
  charts.mem.setOption(gaugeOption(0, '—'));

  // Throughput (empty)
  charts.throughput.setOption(areaChartOption([], [], [], 'Mbps'));

  // History (empty)
  charts.history.setOption({
    tooltip: { trigger:'axis', backgroundColor:'#151d27', borderColor:'#2a3a4e', textStyle:{color:'#c8d6e5',fontFamily:'Share Tech Mono',fontSize:11} },
    legend: { data:['CPU %','Memory %'], textStyle:{color:'#6b7d93',fontFamily:'Share Tech Mono',fontSize:10}, top:5, right:10 },
    grid: { left:50, right:20, top:40, bottom:30 },
    xAxis: { type:'category', data:[], axisLine:{lineStyle:{color:'#1e2a38'}}, axisLabel:{color:'#3d4f63',fontFamily:'Share Tech Mono',fontSize:9}, splitLine:{show:false} },
    yAxis: { type:'value', min:0, max:100, name:'%', nameTextStyle:{color:'#3d4f63',fontFamily:'Share Tech Mono',fontSize:9}, axisLine:{lineStyle:{color:'#1e2a38'}}, axisLabel:{color:'#3d4f63',fontFamily:'Share Tech Mono',fontSize:10}, splitLine:{lineStyle:{color:'#111820'}} },
    series: [
      { name:'CPU %', type:'line', data:[], smooth:true, showSymbol:false, lineStyle:{color:'#00e676',width:1.5}, areaStyle:{color:{type:'linear',x:0,y:0,x2:0,y2:1,colorStops:[{offset:0,color:'rgba(0,230,118,0.15)'},{offset:1,color:'rgba(0,230,118,0)'}]}} },
      { name:'Memory %', type:'line', data:[], smooth:true, showSymbol:false, lineStyle:{color:'#ffab00',width:1.5}, areaStyle:{color:{type:'linear',x:0,y:0,x2:0,y2:1,colorStops:[{offset:0,color:'rgba(255,171,0,0.12)'},{offset:1,color:'rgba(255,171,0,0)'}]}} }
    ]
  });

  // Neighbor graph (empty)
  charts.neighbor.setOption({
    series: [{
      type:'graph', layout:'force', roam:true,
      force:{repulsion:200,edgeLength:[80,130],gravity:0.15},
      label:{show:true,color:'#c8d6e5',fontSize:9,fontFamily:'Share Tech Mono'},
      data:[], links:[]
    }]
  });

  window.addEventListener('resize', () => Object.values(charts).forEach(c => c.resize()));
}

function gaugeOption(value, subtitle) {
  return {
    series: [{
      type:'gauge', startAngle:220, endAngle:-40, min:0, max:100, splitNumber:10, radius:'90%',
      axisLine: { lineStyle:{ width:12, color:[[0.6,'#00e676'],[0.8,'#ffab00'],[1,'#ff1744']] }},
      pointer: { itemStyle:{color:'#c8d6e5'}, width:4, length:'60%' },
      axisTick: { distance:-12, length:6, lineStyle:{color:'#1e2a38',width:1} },
      splitLine: { distance:-14, length:12, lineStyle:{color:'#2a3a4e',width:1} },
      axisLabel: { color:'#3d4f63', distance:20, fontSize:10, fontFamily:'Share Tech Mono' },
      detail: { valueAnimation:true, formatter:'{value}%', color:'#c8d6e5', fontSize:26, fontFamily:'Orbitron', fontWeight:700, offsetCenter:[0,'70%'] },
      title: { offsetCenter:[0,'92%'], fontSize:9, color:'#3d4f63', fontFamily:'JetBrains Mono' },
      data: [{ value: value, name: subtitle }]
    }]
  };
}

function areaChartOption(timestamps, series1, series2, yName) {
  return {
    tooltip: { trigger:'axis', backgroundColor:'#151d27', borderColor:'#2a3a4e', textStyle:{color:'#c8d6e5',fontFamily:'Share Tech Mono',fontSize:11} },
    legend: { data:['Inbound','Outbound'], textStyle:{color:'#6b7d93',fontFamily:'Share Tech Mono',fontSize:10}, top:5, right:10 },
    grid: { left:60, right:20, top:40, bottom:30 },
    xAxis: { type:'category', data:timestamps, axisLine:{lineStyle:{color:'#1e2a38'}}, axisLabel:{color:'#3d4f63',fontFamily:'Share Tech Mono',fontSize:9,interval:'auto'}, splitLine:{show:false} },
    yAxis: { type:'value', name:yName, nameTextStyle:{color:'#3d4f63',fontFamily:'Share Tech Mono',fontSize:9}, axisLine:{lineStyle:{color:'#1e2a38'}}, axisLabel:{color:'#3d4f63',fontFamily:'Share Tech Mono',fontSize:10}, splitLine:{lineStyle:{color:'#111820'}} },
    series: [
      { name:'Inbound', type:'line', data:series1, smooth:true, showSymbol:false, lineStyle:{color:'#00e5ff',width:2}, areaStyle:{color:{type:'linear',x:0,y:0,x2:0,y2:1,colorStops:[{offset:0,color:'rgba(0,229,255,0.25)'},{offset:1,color:'rgba(0,229,255,0)'}]}} },
      { name:'Outbound', type:'line', data:series2, smooth:true, showSymbol:false, lineStyle:{color:'#d500f9',width:2}, areaStyle:{color:{type:'linear',x:0,y:0,x2:0,y2:1,colorStops:[{offset:0,color:'rgba(213,0,249,0.2)'},{offset:1,color:'rgba(213,0,249,0)'}]}} }
    ]
  };
}

// ── Data update handlers ───────────────────────────────────────────

function updateCPU(data) {
  const val = data.five_min || data.five_sec_total || data.one_min || 0;
  charts.cpu.setOption({ series:[{data:[{value:Math.round(val), name:'5-MIN AVG'}]}] });
  const badge = document.getElementById('cpuBadge');
  if (val > 80) { badge.className='panel-badge badge-crit'; badge.textContent='CRITICAL'; }
  else if (val > 60) { badge.className='panel-badge badge-warn'; badge.textContent='ELEVATED'; }
  else { badge.className='panel-badge badge-ok'; badge.textContent='NORMAL'; }

  // Process table (if present in same data or separate)
  if (data.processes) updateProcessTable(data.processes);
}

function updateMemory(data) {
  const val = data.used_pct || 0;
  const subtitle = (data.used_display && data.total_display)
    ? `${data.used_display} / ${data.total_display}` : `${val}%`;
  const color = val > 75 ? '#ffab00' : '#c8d6e5';
  charts.mem.setOption({
    series:[{
      data:[{value:Math.round(val*10)/10, name:subtitle}],
      detail:{color:color, textShadowColor: val>75 ? '#ffab0044' : 'transparent', textShadowBlur: val>75 ? 10 : 0}
    }]
  });
  const badge = document.getElementById('memBadge');
  if (val > 85) { badge.className='panel-badge badge-crit'; badge.textContent='CRITICAL'; }
  else if (val > 70) { badge.className='panel-badge badge-warn'; badge.textContent='ELEVATED'; }
  else { badge.className='panel-badge badge-ok'; badge.textContent='NORMAL'; }
}

function updateProcessTable(processes) {
  if (!processes || !processes.length) return;
  const container = document.getElementById('processContainer');
  let html = '<table class="data-table"><thead><tr><th>PID</th><th>Name</th><th>CPU%</th><th>MEM</th></tr></thead><tbody>';
  processes.slice(0,15).forEach(p => {
    const cpu = p.five_sec || p.cpu_pct || p.five_min || 0;
    const cpuColor = cpu > 5 ? 'var(--amber)' : cpu > 2 ? 'var(--text-secondary)' : 'var(--text-dim)';
    const mem = p.mem_pct ? p.mem_pct+'%' : (p.holding ? formatBytes(p.holding) : '—');
    html += `<tr><td>${p.pid||'—'}</td><td>${p.name||'—'}</td><td style="color:${cpuColor};font-weight:600">${cpu}%</td><td>${mem}</td></tr>`;
  });
  html += '</tbody></table>';
  container.innerHTML = html;
}

function updateInterfaces(data) {
  const intfs = data.interfaces || [];
  if (!intfs.length) return;
  const container = document.getElementById('intfContainer');
  let upCount=0, downCount=0, adminCount=0;
  intfs.forEach(i => {
    const s = (i.status||'').toLowerCase();
    if (s.includes('admin')) adminCount++;
    else if (s === 'up') upCount++;
    else downCount++;
  });

  const badge = document.getElementById('intfBadge');
  badge.className = 'panel-badge badge-ok';
  badge.textContent = `${upCount} UP / ${downCount} DOWN / ${adminCount} ADMIN-DOWN`;

  let html = '<table class="data-table"><thead><tr><th>Interface</th><th>Status</th><th>Protocol</th><th>IP Address</th></tr></thead><tbody>';
  intfs.forEach(i => {
    const s = (i.status||'').toLowerCase();
    const cls = s.includes('admin') ? 'intf-admin' : s === 'up' ? 'intf-up' : 'intf-down';
    html += `<tr>
      <td style="font-weight:600;color:var(--text-primary)">${i.name||'—'}</td>
      <td class="${cls}">${i.status||'—'}</td>
      <td class="${cls}">${i.protocol||'—'}</td>
      <td>${i.ip_address||'—'}</td>
    </tr>`;
  });
  html += '</tbody></table>';
  container.innerHTML = html;
}

function updateInterfaceDetail(data) {
  const intfs = data.interfaces || [];
  if (!intfs.length) return;

  const now = new Date().toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit',hour12:false});
  throughputHistory.timestamps.push(now);

  // Store per-interface rates for this timestamp
  const seen = new Set();
  intfs.forEach(i => {
    const name = i.name || 'unknown';
    seen.add(name);
    if (!throughputHistory.perInterface[name]) {
      // New interface — backfill with zeros so arrays align with timestamps
      const backfill = throughputHistory.timestamps.length - 1;
      throughputHistory.perInterface[name] = {
        inbound: new Array(backfill).fill(0),
        outbound: new Array(backfill).fill(0)
      };
    }
    throughputHistory.perInterface[name].inbound.push(parseInt(i.input_rate_bps || 0));
    throughputHistory.perInterface[name].outbound.push(parseInt(i.output_rate_bps || 0));
  });

  // Interfaces not in this poll get a zero for this timestamp
  for (const [name, hist] of Object.entries(throughputHistory.perInterface)) {
    if (!seen.has(name)) {
      hist.inbound.push(0);
      hist.outbound.push(0);
    }
  }

  // Trim ring buffer
  if (throughputHistory.timestamps.length > THROUGHPUT_MAX) {
    throughputHistory.timestamps.shift();
    for (const hist of Object.values(throughputHistory.perInterface)) {
      hist.inbound.shift();
      hist.outbound.shift();
    }
  }

  // Update dropdown if new interfaces appeared
  let dropdownChanged = false;
  intfs.forEach(i => {
    if (i.name && !knownInterfaces.has(i.name)) {
      knownInterfaces.add(i.name);
      dropdownChanged = true;
    }
  });
  if (dropdownChanged) {
    const select = document.getElementById('intfSelect');
    const current = select.value;
    // Rebuild options: aggregate first, then sorted interface names
    select.innerHTML = '<option value="__aggregate__">All Interfaces</option>';
    [...knownInterfaces].sort().forEach(name => {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      select.appendChild(opt);
    });
    select.value = current; // Preserve selection
  }

  renderThroughputChart();
}

function renderThroughputChart() {
  const select = document.getElementById('intfSelect');
  const selected = select ? select.value : '__aggregate__';
  const len = throughputHistory.timestamps.length;
  if (!len) return;

  let inArr, outArr;

  if (selected === '__aggregate__') {
    // Sum all interfaces per timestamp
    inArr = new Array(len).fill(0);
    outArr = new Array(len).fill(0);
    for (const hist of Object.values(throughputHistory.perInterface)) {
      for (let i = 0; i < len; i++) {
        inArr[i] += (hist.inbound[i] || 0);
        outArr[i] += (hist.outbound[i] || 0);
      }
    }
  } else {
    const hist = throughputHistory.perInterface[selected];
    if (!hist) return;
    inArr = hist.inbound.slice();
    outArr = hist.outbound.slice();
  }

  // Auto-scale unit based on peak
  const peak = Math.max(Math.max(...inArr), Math.max(...outArr), 1);
  let divisor, unit;
  if (peak >= 1000000) { divisor = 1000000; unit = 'Mbps'; }
  else if (peak >= 1000) { divisor = 1000; unit = 'Kbps'; }
  else { divisor = 1; unit = 'bps'; }

  const scaledIn = inArr.map(v => Math.round((v / divisor) * 100) / 100);
  const scaledOut = outArr.map(v => Math.round((v / divisor) * 100) / 100);

  charts.throughput.setOption({
    yAxis: { name: unit },
    xAxis: { data: throughputHistory.timestamps },
    series: [{ data: scaledIn }, { data: scaledOut }]
  });

  // Update badge
  const curIn = inArr[len - 1] / divisor;
  const curOut = outArr[len - 1] / divisor;
  const badge = document.getElementById('thruBadge');
  if (badge) {
    badge.className = 'panel-badge badge-ok';
    const label = selected === '__aggregate__' ? '' : selected + ' ';
    badge.textContent = `${label}▼ ${curIn.toFixed(1)} / ▲ ${curOut.toFixed(1)} ${unit}`;
  }
}

function updateNeighbors(data) {
  const neighbors = data.neighbors || [];
  if (!neighbors.length) return;

  const hostEl = document.getElementById('deviceHostname');
  const hostname = (hostEl ? hostEl.textContent : '') || 'this-device';
  // Strip domain from hostnames (R1.lab.local → R1) but preserve IPs
  const shortHost = /^\d+\.\d+\.\d+\.\d+$/.test(hostname) ? hostname : hostname.split('.')[0];

  const nodes = [{
    name: shortHost,
    symbolSize: 40,
    symbol: 'roundRect',
    itemStyle:{color:'#0a0e14',borderColor:'#00e5ff',borderWidth:2,shadowColor:'#00e5ff44',shadowBlur:12},
    label:{color:'#00e5ff',fontWeight:700,fontSize:11}
  }];
  const links = [];

  neighbors.forEach((n,i) => {
    const fullName = n.device_id || `neighbor-${i}`;
    const name = /^\d+\.\d+\.\d+\.\d+$/.test(fullName) ? fullName : fullName.split('.')[0];
    const caps = (n.capabilities || '').toLowerCase();
    const isRouter = caps.includes('router');
    const isSwitch = caps.includes('switch') || caps.includes('bridge');

    // Node styling by type
    let borderColor, symbol;
    if (isRouter) { borderColor = '#00e5ff'; symbol = 'roundRect'; }
    else if (isSwitch) { borderColor = '#00e676'; symbol = 'rect'; }
    else { borderColor = '#ffab00'; symbol = 'circle'; }

    // Build label with platform/IP detail
    let detail = name;
    if (n.mgmt_ip) detail += '\n' + n.mgmt_ip;

    nodes.push({
      name: name,
      symbolSize: 28,
      symbol: symbol,
      itemStyle:{color:'#111820',borderColor:borderColor,borderWidth:1.5},
      label:{formatter: detail}
    });

    // Edge label: local ↔ remote
    const localShort = (n.local_intf || '').replace(/TenGigabitEthernet/g,'Te').replace(/GigabitEthernet/g,'Gi').replace(/FastEthernet/g,'Fa').replace(/Ethernet/g,'Eth');
    const remoteShort = (n.remote_intf || '').replace(/TenGigabitEthernet/g,'Te').replace(/GigabitEthernet/g,'Gi').replace(/FastEthernet/g,'Fa').replace(/Ethernet/g,'Eth');
    const edgeLabel = remoteShort ? `${localShort} ↔ ${remoteShort}` : localShort;

    links.push({
      source: shortHost,
      target: name,
      label: edgeLabel,
      lineStyle:{color:'#1e2a38',width:1.5,curveness: neighbors.length > 3 ? 0.15 : 0}
    });
  });

  charts.neighbor.setOption({
    tooltip:{
      show:true,
      backgroundColor:'#151d27',
      borderColor:'#2a3a4e',
      textStyle:{color:'#c8d6e5',fontFamily:'Share Tech Mono',fontSize:10}
    },
    series:[{
      type:'graph', layout:'force', roam:true,
      force:{repulsion:200, edgeLength:[80,130], gravity:0.15},
      label:{show:true, color:'#c8d6e5', fontSize:9, fontFamily:'Share Tech Mono'},
      data:nodes,
      links:links,
      edgeLabel:{show:true, fontSize:8, fontFamily:'Share Tech Mono', color:'#3d4f63',
        formatter: function(p){ return p.data.label || ''; }
      }
    }]
  });

  // Force resize in case chart was initialized before container was visible
  charts.neighbor.resize();
}

function updateLog(data) {
  const entries = data.entries || [];
  if (!entries.length) return;
  const container = document.getElementById('logContainer');
  const badge = document.getElementById('logBadge');

  const critCount = entries.filter(e => (e.severity||7) <= 3).length;
  if (critCount > 0) { badge.className='panel-badge badge-warn'; badge.textContent=`${critCount} WARNINGS`; }
  else { badge.className='panel-badge badge-ok'; badge.textContent='CLEAR'; }

  let html = '';
  // Entries arrive newest-first from _post_process_log — just take the first 30
  entries.slice(0, 30).forEach(e => {
    const sev = e.severity || 6;
    html += `<div class="log-entry">
      <span class="log-ts">${e.timestamp||''}</span>
      <span class="log-sev-${sev}">%${e.facility||'SYS'}-${sev}-${e.mnemonic||'MSG'}</span>:
      <span class="log-msg">${e.message||''}</span>
    </div>`;
  });
  container.innerHTML = html;
}

function updateHistory(cpuHistory, memHistory) {
  if (!cpuHistory.length && !memHistory.length) return;

  const timestamps = cpuHistory.map(h => {
    const d = new Date(h.timestamp * 1000);
    return d.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit',hour12:false});
  });

  charts.history.setOption({
    xAxis:{data:timestamps},
    series:[
      {data:cpuHistory.map(h => h.data.five_min || h.data.five_sec || 0)},
      {data:memHistory.map(h => h.data.used_pct || 0)}
    ]
  });
}

// ── JSON Debug Modal ──────────────────────────────────────────────

let currentDebugJSON = '';

function showDebug(collectionKey) {
  const overlay = document.getElementById('debugOverlay');
  const title = document.getElementById('debugTitle');
  const body = document.getElementById('debugBody');
  const parserTag = document.getElementById('debugParserTag');
  const templateTag = document.getElementById('debugTemplateTag');

  title.textContent = collectionKey.replace(/_/g, ' ').toUpperCase();

  let data = null;

  // Special case: history buffer
  if (collectionKey === '_history') {
    title.textContent = 'HISTORY BUFFER';
    // Use cached history data (populated by refreshHistory)
    data = collectionCache['_history'] || null;
    if (!data && bridge) {
      // Async fetch — update modal when ready
      Promise.all([
        bridgeCall(bridge.getHistory, 'cpu'),
        bridgeCall(bridge.getHistory, 'memory')
      ]).then(function(results) {
        try {
          var cpuH = JSON.parse(results[0]);
          var memH = JSON.parse(results[1]);
          data = { cpu_history: cpuH, memory_history: memH };
          collectionCache['_history'] = data;
          currentDebugJSON = JSON.stringify(data, null, 2);
          body.innerHTML = syntaxHighlight(currentDebugJSON);
        } catch(e) {
          body.innerHTML = '<span style="color:var(--red)">History parse error: ' + e.message + '</span>';
        }
      });
    }
    parserTag.style.display = 'none';
    templateTag.style.display = 'none';
  } else {
    // Use cache for regular collections (always up-to-date from signals)
    data = collectionCache[collectionKey] || null;

    // Show parser metadata tags
    if (data && data._parsed_by) {
      parserTag.style.display = '';
      parserTag.textContent = data._parsed_by.toUpperCase();
      parserTag.className = 'debug-parser-tag parser-' + data._parsed_by;
    } else {
      parserTag.style.display = 'none';
    }

    if (data && data._template && data._template !== 'inline') {
      templateTag.style.display = '';
      templateTag.textContent = data._template;
      templateTag.className = 'debug-parser-tag';
      templateTag.style.background = '#1e2a3844';
      templateTag.style.color = 'var(--text-secondary)';
      templateTag.style.border = '1px solid var(--border)';
    } else {
      templateTag.style.display = 'none';
    }
  }

  if (data) {
    currentDebugJSON = JSON.stringify(data, null, 2);
    body.innerHTML = syntaxHighlight(currentDebugJSON);
  } else {
    currentDebugJSON = '';
    body.innerHTML = '<span style="color:var(--text-dim)">No data collected yet for this panel.\n\n'
      + 'Data appears here after the first successful poll cycle.\n'
      + 'If this persists, check the template configuration for\n'
      + 'this collection and vendor combination.</span>';
  }

  // Update debug button state
  updateDebugButtons();

  overlay.classList.add('visible');
  document.addEventListener('keydown', debugEscHandler);
}

function closeDebug() {
  document.getElementById('debugOverlay').classList.remove('visible');
  document.removeEventListener('keydown', debugEscHandler);
}

function debugEscHandler(e) {
  if (e.key === 'Escape') closeDebug();
}

// Close on click outside modal
document.addEventListener('click', function(e) {
  const overlay = document.getElementById('debugOverlay');
  if (e.target === overlay) closeDebug();
});

function copyDebugJSON() {
  if (!currentDebugJSON) return;
  const btn = document.getElementById('debugCopyBtn');

  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(currentDebugJSON).then(() => {
      btn.textContent = 'Copied';
      btn.classList.add('copied');
      setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500);
    });
  } else {
    // Fallback for QWebEngine
    const ta = document.createElement('textarea');
    ta.value = currentDebugJSON;
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    document.body.appendChild(ta);
    ta.select();
    try {
      document.execCommand('copy');
      btn.textContent = 'Copied';
      btn.classList.add('copied');
      setTimeout(() => { btn.textContent = 'Copy'; btn.classList.remove('copied'); }, 1500);
    } catch(e) {
      btn.textContent = 'Failed';
      setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
    }
    document.body.removeChild(ta);
  }
}

function syntaxHighlight(json) {
  // Escape HTML entities
  json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

  return json.replace(
    /("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g,
    function(match) {
      let cls = 'json-number';
      if (/^"/.test(match)) {
        if (/:$/.test(match)) {
          // Key
          if (/^"_/.test(match)) {
            cls = 'json-meta-key'; // Metadata keys (_parsed_by, _template, _error)
          } else {
            cls = 'json-key';
          }
        } else {
          cls = 'json-string';
        }
      } else if (/true|false/.test(match)) {
        cls = 'json-bool';
      } else if (/null/.test(match)) {
        cls = 'json-null';
      }
      return '<span class="' + cls + '">' + match + '</span>';
    }
  );
}

function updateDebugButtons() {
  // Update { } button states based on whether we have data
  document.querySelectorAll('.debug-btn').forEach(btn => {
    const panel = btn.closest('.panel');
    if (!panel) return;
    const key = panel.getAttribute('data-collection');
    if (!key) return;
    const data = collectionCache[key];
    if (data) {
      if (data._error || data._parsed_by === 'none') {
        btn.classList.add('has-error');
        btn.classList.remove('has-data');
      } else {
        btn.classList.add('has-data');
        btn.classList.remove('has-error');
      }
    }
  });
}

// ── Spinner timeout ───────────────────────────────────────────────

function checkSpinnerTimeouts() {
  document.querySelectorAll('.panel[data-collection]').forEach(panel => {
    const key = panel.getAttribute('data-collection');
    if (key === 'history' || key === '_history') return;
    if (collectionCache[key]) return; // Has data, skip

    if (totalCycles >= SPINNER_TIMEOUT_CYCLES) {
      const waiting = panel.querySelector('.waiting');
      if (waiting) {
        waiting.innerHTML = '<div class="no-data">No data</div>';
      }
    }
  });
}

// ── Helpers ────────────────────────────────────────────────────────

function formatBytes(bytes) {
  if (bytes > 1073741824) return (bytes/1073741824).toFixed(1)+'G';
  if (bytes > 1048576) return (bytes/1048576).toFixed(0)+'M';
  if (bytes > 1024) return (bytes/1024).toFixed(0)+'K';
  return bytes+'B';
}

function updateClock() {
  document.getElementById('liveClock').textContent =
    new Date().toLocaleTimeString('en-US',{hour12:false}) + ' UTC';
}

// ── QWebChannel connection ─────────────────────────────────────────

function connectBridge(retryCount) {
  retryCount = retryCount || 0;
  try {
    new QWebChannel(qt.webChannelTransport, function(channel) {
      bridge = channel.objects.telemetry;
      if (!bridge) {
        console.warn('Bridge object not found, retry ' + retryCount);
        if (retryCount < 10) setTimeout(() => connectBridge(retryCount + 1), 1000);
        return;
      }
      console.log('QWebChannel connected');

      // Listen for state changes
      bridge.stateChanged.connect(function(collection, jsonStr) {
        try {
          const data = JSON.parse(jsonStr);
          collectionCache[collection] = data; // Cache for debug
          handleUpdate(collection, data);
          updateDebugButtons();
        } catch(e) { console.error('Parse error:', collection, e); }
      });

      // Listen for cycle completion — refresh history
      bridge.cycleComplete.connect(function() {
        totalCycles++;
        refreshHistory();
        checkSpinnerTimeouts();
      });

      // Listen for connection status
      bridge.connectionStatus.connect(function(status) {
        const el = document.getElementById('connStatus');
        if (status === 'connected') {
          el.innerHTML = '<span class="status-dot"></span>CONNECTED';
        } else if (status === 'disconnected') {
          el.innerHTML = '<span class="status-dot" style="background:var(--red);box-shadow:0 0 6px var(--red)"></span>DISCONNECTED';
        } else {
          el.innerHTML = '<span class="status-dot" style="background:var(--red);box-shadow:0 0 6px var(--red)"></span>ERROR';
        }
      });

      // Listen for device info
      bridge.deviceInfoChanged.connect(function(jsonStr) {
        try { updateDeviceInfo(JSON.parse(jsonStr)); } catch(e) {}
      });

      // Load initial snapshot (fixes "Waiting for connection" header bug)
      loadInitialData();

      // Retry initial data after a short delay (signal timing fix)
      setTimeout(loadInitialData, 2000);

      // Start polling for updates in case signals are missed
      setInterval(function() {
        if (!bridge) return;
        bridgeCall(bridge.getSnapshot).then(function(snapStr) {
          try {
            var snap = JSON.parse(snapStr);
            if (snap.collections) {
              Object.keys(snap.collections).forEach(function(k) {
                collectionCache[k] = snap.collections[k];
                handleUpdate(k, snap.collections[k]);
              });
            }
            if (snap.device && Object.keys(snap.device).length) updateDeviceInfo(snap.device);
            if (snap.history) updateHistory(snap.history.cpu || [], snap.history.memory || []);
            updateDebugButtons();
          } catch(e) {}
        }).catch(function() {});
      }, 5000);
    });
  } catch(e) {
    console.error('QWebChannel error:', e);
    if (retryCount < 10) setTimeout(() => connectBridge(retryCount + 1), 1000);
  }
}

function loadInitialData() {
  if (!bridge) return;
  bridgeCall(bridge.getSnapshot).then(function(snapshot) {
    try {
      var data = JSON.parse(snapshot);
      if (data.device && Object.keys(data.device).length) updateDeviceInfo(data.device);
      if (data.collections) {
        Object.keys(data.collections).forEach(function(k) {
          collectionCache[k] = data.collections[k];
          handleUpdate(k, data.collections[k]);
        });
      }
      if (data.history) {
        collectionCache['_history'] = data.history;
        updateHistory(data.history.cpu || [], data.history.memory || []);
      }
      updateDebugButtons();
    } catch(e) { console.log('No initial data yet'); }
  }).catch(function() { console.log('No initial data yet'); });
}

function handleUpdate(collection, data) {
  // Check for error collections
  if (data && data._parsed_by === 'none' && data._error) {
    console.warn(`Parse failed for ${collection}: ${data._error}`);
    // Don't update the widget, but cache the error for debug inspection
    return;
  }

  switch(collection) {
    case 'cpu': updateCPU(data); break;
    case 'memory': updateMemory(data); break;
    case 'interfaces': updateInterfaces(data); break;
    case 'interface_detail': updateInterfaceDetail(data); break;
    case 'neighbors': updateNeighbors(data); break;
    case 'log': updateLog(data); break;
    case 'processes': updateProcessTable(data.processes || []); break;
  }
}

function refreshHistory() {
  if (!bridge) return;
  Promise.all([
    bridgeCall(bridge.getHistory, 'cpu'),
    bridgeCall(bridge.getHistory, 'memory')
  ]).then(function(results) {
    try {
      var cpuH = JSON.parse(results[0]);
      var memH = JSON.parse(results[1]);
      collectionCache['_history'] = { cpu: cpuH, memory: memH };
      updateHistory(cpuH, memH);
    } catch(e) { console.debug('History parse:', e.message); }
  }).catch(function() {});
}

function updateDeviceInfo(info) {
  document.getElementById('deviceHostname').textContent = info.hostname || info.ip || '—';
  document.getElementById('deviceSubtitle').textContent = [info.vendor, info.ip].filter(Boolean).join(' · ');
  document.getElementById('vendorLabel').textContent = (info.vendor || '—').replace(/_/g,' ');

  // Update info strip
  const strip = document.getElementById('infoStrip');
  let chips = '';
  if (info.ip) chips += `<div class="info-chip"><span class="label">IP</span><span class="value">${info.ip}</span></div>`;
  if (info.vendor) chips += `<div class="info-chip"><span class="label">Platform</span><span class="value">${info.vendor.replace(/_/g,' ')}</span></div>`;
  if (info.username) chips += `<div class="info-chip"><span class="label">User</span><span class="value">${info.username}</span></div>`;
  if (info.tags && info.tags.length) chips += `<div class="info-chip"><span class="label">Tags</span><span class="value">${info.tags.join(', ')}</span></div>`;
  if (chips) strip.innerHTML = chips;
}

// ── Init ───────────────────────────────────────────────────────────

document.addEventListener('DOMContentLoaded', function() {
  initCharts();
  setInterval(updateClock, 1000);
  updateClock();

  // Connect to Python bridge
  if (typeof qt !== 'undefined') {
    connectBridge();
  } else {
    console.log('No QWebChannel — running in standalone browser mode');
    document.getElementById('connStatus').innerHTML =
      '<span class="status-dot" style="background:var(--amber);box-shadow:0 0 6px var(--amber)"></span>DEMO MODE';
  }
});
</script>
</body>
</html>